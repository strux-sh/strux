/***
 *
 *
 *  BSP YAML (bsp.yaml) Validation Schema
 *
 */

import { z } from "zod"
import { readFileSync } from "fs"
import { join } from "path"
import { Settings } from "../settings"
import { Logger } from "../utils/log"
import { fileExists } from "../utils/path"

// Display configuration schema
const DisplaySchema = z.object({
    resolution: z.string(),
}).transform((data) => {
    const parts = data.resolution.split("x")
    const width = parseInt(parts[0] ?? "0", 10)
    const height = parseInt(parts[1] ?? "0", 10)
    return {
        ...data,
        width,
        height,
    }
})

// Script step type schema
// These define the lifecycle hooks available during the build process
const ScriptStepSchema = z.enum([
    // Build lifecycle
    "before_build",     // Very first step, before anything else
    "after_build",      // Very last step, after everything completes

    // Frontend compilation
    "before_frontend",  // Before frontend (Vue/React/vanilla) compilation
    "after_frontend",   // After frontend compilation

    // Application (main.go) compilation
    "before_application",
    "after_application",

    // Cage compositor
    "before_cage",
    "after_cage",

    // WPE WebKit extension
    "before_wpe",
    "after_wpe",

    // Strux client binary
    "before_client",
    "after_client",

    // Kernel (conditional: only runs if boot.kernel.custom_kernel: true)
    "before_kernel",
    "after_kernel",

    // Bootloader (conditional: only runs if boot.bootloader.enabled: true)
    "before_bootloader",
    "after_bootloader",

    // RootFS creation
    "before_rootfs",
    "after_rootfs",

    // Final image bundling
    "before_bundle",    // After rootfs post-processing, before make_image
    "make_image",       // Creates the final disk image for the target device

    // Flash script (handled separately by `strux flash` command, not during build)
    "flash_script",
])

// Export the type for use in other modules
export type ScriptStep = z.infer<typeof ScriptStepSchema>

// Script configuration schema
const ScriptSchema = z.object({
    // Path to the script file (relative to the BSP directory)
    location: z.string(),
    // Which build step to run this script at
    step: ScriptStepSchema,
    // Files generated by this script (relative to dist/) - if all exist and not --clean, skip
    cached_generated_artifacts: z.array(z.string()).optional(),
    // Files this script depends on (relative to project) - if any changed, re-run
    depends_on: z.array(z.string()).optional(),
    // Human-readable description for logging
    description: z.string().optional(),
})

// Export script type for use in build logic
export type BSPScript = z.infer<typeof ScriptSchema>

// Bootloader configuration schema
const BootloaderSchema = z.object({
    enabled: z.boolean(),
    type: z.enum(["grub", "u-boot"]).optional(),
    version: z.string().optional(),
    source: z.string().optional(),
    defconfig: z.string().optional(),
    fragments: z.array(z.string()).optional(),
    patches: z.array(z.string()).optional(),
})

// Device tree configuration schema
const DeviceTreeSchema = z.object({
    dts: z.string(),
    overlays: z.array(z.string()).optional(),
    include_paths: z.array(z.string()).optional(),
})

// Kernel configuration schema
const KernelSchema = z.object({
    custom_kernel: z.boolean(),
    source: z.string().optional(),
    version: z.string().optional(),
    defconfig: z.string().optional(),
    fragments: z.array(z.string()).optional(),
    patches: z.array(z.string()).optional(),
    device_tree: DeviceTreeSchema.optional(),
})

// Boot configuration schema
const BootSchema = z.object({
    bootloader: BootloaderSchema.optional(),
    kernel: KernelSchema.optional(),
})

// RootFS configuration schema
const RootFSSchema = z.object({
    overlay: z.string().optional(),
    packages: z.array(z.string()).optional(),
})

// BSP configuration schema
const BSPConfigSchema = z.object({
    name: z.string(),
    description: z.string(),
    display: DisplaySchema.optional(),
    arch: z.string(),
    hostname: z.string(),
    scripts: z.array(ScriptSchema).optional(),
    boot: BootSchema.optional(),
    rootfs: RootFSSchema.optional(),
})

// Main bsp.yaml schema
export const BSPYamlSchema = z.object({
    strux_version: z.string(),
    bsp: BSPConfigSchema,
})

export type BSPYaml = z.infer<typeof BSPYamlSchema>

export class BSPYamlValidator {

    public static schema = BSPYamlSchema

    /**
     * Validates the bsp.yaml file and returns true if valid, false otherwise
     */
    public static validate(filePath?: string): boolean {
        const result = this.safeValidate(filePath)
        return result.success
    }

    /**
     * Safely validates the bsp.yaml file and returns a result object
     */
    public static safeValidate(filePath?: string): {
        success: boolean
        data?: BSPYaml
        error?: z.ZodError | Error
    } {
        const yamlPath = filePath ?? this.getDefaultPath()

        if (!fileExists(yamlPath)) {
            return {
                success: false,
                error: new Error(`bsp.yaml file not found: ${yamlPath}`),
            }
        }

        try {
            const fileContent = readFileSync(yamlPath, "utf-8")
            const parsed = Bun.YAML.parse(fileContent)
            const result = BSPYamlSchema.safeParse(parsed)

            if (result.success) {
                return { success: true, data: result.data }
            }

            return { success: false, error: result.error }
        } catch (error) {
            return {
                success: false,
                error: error instanceof Error
                    ? error
                    : new Error(`Failed to parse YAML: ${String(error)}`),
            }
        }
    }

    /**
     * Validates and loads the bsp.yaml file into the Settings class
     * Throws an error if validation fails
     */
    public static validateAndLoad(filePath?: string, bspName?: string): BSPYaml {
        const yamlPath = filePath ?? this.getDefaultPath(bspName)

        if (!fileExists(yamlPath)) {
            Logger.errorWithExit(`bsp.yaml file not found: ${yamlPath}`)
            // This will never execute, but satisfies TypeScript's return type check
            throw new Error("File not found")
        }

        try {
            const fileContent = readFileSync(yamlPath, "utf-8")
            const parsed = Bun.YAML.parse(fileContent)
            const validated = BSPYamlSchema.parse(parsed)

            // Load relevant fields into Settings if needed
            if (validated.bsp.arch) {
                // Map arch values to Settings.ArchType
                const arch = validated.bsp.arch.toLowerCase()
                if (arch === "arm64" || arch === "aarch64") {
                    Settings.targetArch = "arm64"
                } else if (arch === "x86_64" || arch === "amd64") {
                    Settings.targetArch = "x86_64"
                } else if (arch === "armhf" || arch === "armv7" || arch === "arm") {
                    Settings.targetArch = "armhf"
                }
            }

            // Store BSP config in Settings
            Settings.bsp = validated.bsp!

            return validated
        } catch (error) {
            if (error instanceof z.ZodError) {
                Logger.error("bsp.yaml validation failed:")
                error.issues.forEach((issue: z.ZodIssue) => {
                    const path = issue.path.join(".")
                    Logger.error(`  ${path}: ${issue.message}`)
                })
                Logger.errorWithExit("Please fix the errors in bsp.yaml and try again.")
                // This will never execute, but satisfies TypeScript's return type check
                throw new Error("Validation failed")
            }

            const errorMessage = error instanceof Error
                ? error.message
                : String(error)
            Logger.errorWithExit(`Failed to parse bsp.yaml: ${errorMessage}`)
            // This will never execute, but satisfies TypeScript's return type check
            throw new Error("Parse failed")
        }
    }

    /**
     * Gets the default path for bsp.yaml based on Settings or provided BSP name
     */
    private static getDefaultPath(bspName?: string): string {
        // If BSP name is provided, use it
        if (bspName) {
            return join(Settings.projectPath, "bsp", bspName, "bsp.yaml")
        }

        // Otherwise, try to get BSP name from Settings.main if available
        if (Settings.main?.bsp) {
            return join(Settings.projectPath, "bsp", Settings.main.bsp, "bsp.yaml")
        }

        // Fallback: assume qemu (common default)
        return join(Settings.projectPath, "bsp", "qemu", "bsp.yaml")
    }

}

